import { BlockFrostAPI, BlockfrostServerError } from '@blockfrost/blockfrost-js';
import Big from 'big.js';
import invariant from '@minswap/tiny-invariant';

var NetworkId = /* @__PURE__ */ ((NetworkId2) => {
  NetworkId2[NetworkId2["TESTNET"] = 0] = "TESTNET";
  NetworkId2[NetworkId2["MAINNET"] = 1] = "MAINNET";
  return NetworkId2;
})(NetworkId || {});

const ORDER_ADDRESS = {
  [NetworkId.TESTNET]: "addr_test1zzn9efv2f6w82hagxqtn62ju4m293tqvw0uhmdl64ch8uwurajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upq932hcy",
  [NetworkId.MAINNET]: "addr1zxn9efv2f6w82hagxqtn62ju4m293tqvw0uhmdl64ch8uw6j2c79gy9l76sdg0xwhd7r0c0kna0tycz4y5s6mlenh8pq6s3z70"
};
const POOL_ADDRESS_LIST = {
  [NetworkId.TESTNET]: [
    "addr_test1zrsnz7c4974vzdpxu65ruphl3zjdvtxw8strf2c2tmqnxzvrajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upqs8q93k"
  ],
  [NetworkId.MAINNET]: [
    "addr1z8snz7c4974vzdpxu65ruphl3zjdvtxw8strf2c2tmqnxz2j2c79gy9l76sdg0xwhd7r0c0kna0tycz4y5s6mlenh8pq0xmsha",
    "addr1z8snz7c4974vzdpxu65ruphl3zjdvtxw8strf2c2tmqnxzfgf0jgfz5xdvg2pges20usxhw8zwnkggheqrxwmxd6huuqss46eh",
    "addr1z8snz7c4974vzdpxu65ruphl3zjdvtxw8strf2c2tmqnxzwccf8ywaly0m99ngq68lus48lmafut7ku9geawu8u6k49suv42qq",
    "addr1z8snz7c4974vzdpxu65ruphl3zjdvtxw8strf2c2tmqnxz02znpd777wgl9wwpk0dvdzuxn93mqh82q7vv6s9jn25rws52z94g",
    "addr1z8snz7c4974vzdpxu65ruphl3zjdvtxw8strf2c2tmqnxz2jyskd3y6etkv8ye450545xu6q4jfq5hv4e0uxwkpf8lsq048y90",
    "addr1z8snz7c4974vzdpxu65ruphl3zjdvtxw8strf2c2tmqnxztnqm37tpj0q63s0qns5wfe4flqzqqg55760472n7yt4v8skpaj3k"
  ]
};
const POOL_ADDRESS_SET = {
  [NetworkId.TESTNET]: new Set(POOL_ADDRESS_LIST[NetworkId.TESTNET]),
  [NetworkId.MAINNET]: new Set(POOL_ADDRESS_LIST[NetworkId.MAINNET])
};
const FACTORY_POLICY_ID = "13aa2accf2e1561723aa26871e071fdf32c867cff7e7d50ad470d62f";
const FACTORY_ASSET_NAME = "4d494e53574150";
const LP_POLICY_ID = "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86";
const POOL_NFT_POLICY_ID = "0be55d262b29f564998ff81efe21bdc0022621c12f15af08d0f2ddb1";

function normalizeAssets(a, b) {
  if (a === "lovelace") {
    return [a, b];
  }
  if (b === "lovelace") {
    return [b, a];
  }
  if (a < b) {
    return [a, b];
  } else {
    return [b, a];
  }
}
class PoolState {
  constructor(txIn, value, datumHash) {
    this.txIn = txIn;
    this.value = value;
    this.datumHash = datumHash;
    const nft = value.find(({ unit }) => unit.startsWith(POOL_NFT_POLICY_ID));
    invariant(nft, "pool doesn't have NFT");
    const poolId = nft.unit.slice(56);
    const relevantAssets = value.filter(({ unit }) => !unit.startsWith(FACTORY_POLICY_ID) && !unit.endsWith(poolId));
    switch (relevantAssets.length) {
      case 2: {
        this.assetA = "lovelace";
        const nonADAAssets = relevantAssets.filter(({ unit }) => unit !== "lovelace");
        invariant(nonADAAssets.length === 1, "pool must have 1 non-ADA asset");
        this.assetB = nonADAAssets[0].unit;
        break;
      }
      case 3: {
        const nonADAAssets = relevantAssets.filter(({ unit }) => unit !== "lovelace");
        invariant(nonADAAssets.length === 2, "pool must have 1 non-ADA asset");
        [this.assetA, this.assetB] = normalizeAssets(nonADAAssets[0].unit, nonADAAssets[1].unit);
        break;
      }
      default:
        throw new Error("pool must have 2 or 3 assets except factory, NFT and LP tokens");
    }
  }
  get nft() {
    const nft = this.value.find(({ unit }) => unit.startsWith(POOL_NFT_POLICY_ID));
    invariant(nft, "pool doesn't have NFT");
    return nft.unit;
  }
  get id() {
    return this.nft.slice(POOL_NFT_POLICY_ID.length);
  }
  get assetLP() {
    return `${LP_POLICY_ID}${this.id}`;
  }
  get reserveA() {
    return BigInt(this.value.find(({ unit }) => unit === this.assetA)?.quantity ?? "0");
  }
  get reserveB() {
    return BigInt(this.value.find(({ unit }) => unit === this.assetB)?.quantity ?? "0");
  }
  getAmountOut(assetIn, amountIn) {
    invariant(assetIn === this.assetA || assetIn === this.assetB, `asset ${assetIn} doesn't exist in pool ${this.assetA}-${this.assetB}`);
    const [reserveIn, reserveOut] = assetIn === this.assetA ? [this.reserveA, this.reserveB] : [this.reserveB, this.reserveA];
    const amtOutNumerator = amountIn * 997n * reserveOut;
    const amtOutDenominator = amountIn * 997n + reserveIn * 1000n;
    const priceImpactNumerator = reserveOut * amountIn * amtOutDenominator * 997n - amtOutNumerator * reserveIn * 1000n;
    const priceImpactDenominator = reserveOut * amountIn * amtOutDenominator * 1000n;
    return {
      amountOut: amtOutNumerator / amtOutDenominator,
      priceImpact: new Big(priceImpactNumerator.toString()).mul(new Big(100)).div(new Big(priceImpactDenominator.toString()))
    };
  }
  getAmountIn(assetOut, amountOut) {
    invariant(assetOut === this.assetA || assetOut === this.assetB, `asset ${assetOut} doesn't exist in pool ${this.assetA}-${this.assetB}`);
    const [reserveIn, reserveOut] = assetOut === this.assetB ? [this.reserveA, this.reserveB] : [this.reserveB, this.reserveA];
    const amtInNumerator = reserveIn * amountOut * 1000n;
    const amtInDenominator = (reserveOut - amountOut) * 997n;
    const priceImpactNumerator = reserveOut * amtInNumerator * 997n - amountOut * amtInDenominator * reserveIn * 1000n;
    const priceImpactDenominator = reserveOut * amtInNumerator * 1000n;
    return {
      amountIn: amtInNumerator / amtInDenominator + 1n,
      priceImpact: new Big(priceImpactNumerator.toString()).mul(new Big(100)).div(new Big(priceImpactDenominator.toString()))
    };
  }
}
function checkValidPoolOutput(networkId, poolAddress, value, datumHash) {
  invariant(POOL_ADDRESS_SET[networkId].has(poolAddress), `invalid pool address: ${poolAddress}`);
  if (value.find(({ unit }) => unit === `${FACTORY_POLICY_ID}${FACTORY_ASSET_NAME}`)?.quantity !== "1") {
    throw new Error(`expect pool to have 1 factory token`);
  }
  invariant(datumHash, `expect pool to have datum hash, got ${datumHash}`);
}
function isValidPoolOutput(networkId, poolAddress, value, datumHash) {
  try {
    checkValidPoolOutput(networkId, poolAddress, value, datumHash);
    return true;
  } catch (err) {
    return false;
  }
}

class BlockfrostAdapter {
  constructor({
    projectId,
    networkId = NetworkId.MAINNET
  }) {
    this.networkId = networkId;
    this.api = new BlockFrostAPI({
      projectId,
      isTestnet: networkId === NetworkId.TESTNET
    });
  }
  async getPools({
    page,
    count = 100,
    order = "asc",
    poolAddress
  }) {
    const utxos = await this.api.addressesUtxos(poolAddress, {
      count,
      order,
      page
    });
    return utxos.filter((utxo) => isValidPoolOutput(this.networkId, poolAddress, utxo.amount, utxo.data_hash)).map((utxo) => new PoolState({ txHash: utxo.tx_hash, index: utxo.output_index }, utxo.amount, utxo.data_hash));
  }
  async getPoolById({
    id
  }) {
    const nft = `${POOL_NFT_POLICY_ID}${id}`;
    const nftTxs = await this.api.assetsTransactions(nft, {
      count: 1,
      page: 1,
      order: "desc"
    });
    if (nftTxs.length === 0) {
      return null;
    }
    return this.getPoolInTx({ txHash: nftTxs[0].tx_hash });
  }
  async getPoolHistory({
    id,
    page = 1,
    count = 100,
    order = "desc"
  }) {
    const nft = `${POOL_NFT_POLICY_ID}${id}`;
    const nftTxs = await this.api.assetsTransactions(nft, {
      count,
      page,
      order
    });
    return nftTxs.map((tx) => ({
      txHash: tx.tx_hash,
      txIndex: tx.tx_index,
      blockHeight: tx.block_height,
      time: new Date(Number(tx.block_time) * 1e3)
    }));
  }
  async getPoolInTx({
    txHash
  }) {
    const poolTx = await this.api.txsUtxos(txHash);
    const poolUtxo = poolTx.outputs.find((o) => POOL_ADDRESS_SET[this.networkId].has(o.address));
    if (!poolUtxo) {
      return null;
    }
    checkValidPoolOutput(this.networkId, poolUtxo.address, poolUtxo.amount, poolUtxo.data_hash);
    return new PoolState({ txHash, index: poolUtxo.output_index }, poolUtxo.amount, poolUtxo.data_hash);
  }
  async getAssetDecimals(asset) {
    if (asset === "lovelace") {
      return 6;
    }
    try {
      const assetAInfo = await this.api.assetsById(asset);
      return assetAInfo.metadata?.decimals ?? 0;
    } catch (err) {
      if (err instanceof BlockfrostServerError && err.status_code === 404) {
        return 0;
      }
      throw err;
    }
  }
  async getPoolPrice({
    pool,
    decimalsA,
    decimalsB
  }) {
    if (decimalsA === void 0) {
      decimalsA = await this.getAssetDecimals(pool.assetA);
    }
    if (decimalsB === void 0) {
      decimalsB = await this.getAssetDecimals(pool.assetB);
    }
    const adjustedReserveA = Big(pool.reserveA.toString()).div(Big(10).pow(decimalsA));
    const adjustedReserveB = Big(pool.reserveB.toString()).div(Big(10).pow(decimalsB));
    const priceAB = adjustedReserveA.div(adjustedReserveB);
    const priceBA = adjustedReserveB.div(adjustedReserveA);
    return [priceAB, priceBA];
  }
}

export { BlockfrostAdapter, FACTORY_ASSET_NAME, FACTORY_POLICY_ID, LP_POLICY_ID, NetworkId, ORDER_ADDRESS, POOL_ADDRESS_LIST, POOL_ADDRESS_SET, POOL_NFT_POLICY_ID, PoolState };
//# sourceMappingURL=index.es.js.map
